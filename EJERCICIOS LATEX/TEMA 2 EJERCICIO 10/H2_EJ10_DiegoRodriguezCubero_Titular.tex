\documentclass[aspectratio=169]{beamer}

% Tema y configuración
\usetheme{Madrid}
\usecolortheme{default}

% Paquetes necesarios
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
% Habilitar UTF-8 dentro de lstlisting (acentos, ñ, etc.)
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{verbatim}
% Para dibujos con TikZ
\usepackage{tikz}
\usetikzlibrary{positioning,trees}

% Configuración de listings para código
\lstset{
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    inputencoding=utf8,
    % Mapeo de caracteres españoles para que no falle la compilación
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'\i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
             {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
             {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {ü}{{\"u}}1 {Ü}{{\"U}}1
}

% Estilo y configuración de listings
\input{estilo.tex}

% Información del documento
\title{Hoja 2: Ejercicio 10}
\subtitle{Ramificación y poda}
\author{Diego Rodríguez Cubero}
\institute{UCM}

% Logo (opcional)
% \logo{\includegraphics[height=1cm]{images/logo.png}}

\begin{document}

% Diapositiva de título
\begin{frame}
    \titlepage
\end{frame}

% Tabla de contenidos
\begin{frame}{Contenidos}
    \tableofcontents
\end{frame}

% Sección 1
\section{Enunciado del problema}
\begin{frame}{Enunciado del problema}
    \begin{block}{Ejercicio 10}
        Una de las pruebas habituales del concurso Supervivientes es la construcción de una cabaña rudimentaria cuyo techo es una simple lona soportada por cuatro pilares. Los concursantes dispondrán de $n$ de fragmentos de caña de longitudes enteras $l_1,\cdots , l_n$ ensamblando los cuales deberán obtener los cuatro pilares. El objetivo es que sus alturas queden razonablemente equilibradas y sean lo más altas posibles. Precisando, desarrollar el problema buscando maximizar el pilar más bajo de los cuatro.

    \end{block}
\end{frame}

% Sección 2
\section{Idea general}
\begin{frame}{Idea general}
    Para resolver este problema, podemos utilizar una técnica de ramificación y poda. La idea es generar todas las posibles combinaciones de los fragmentos de caña para formar los cuatro pilares, y luego podar aquellas combinaciones que no cumplan con el objetivo de maximizar el pilar más bajo.
\end{frame}

% Sección 3
\section{Espacio de soluciones}
\begin{frame}{Espacio de soluciones}
    El espacio de soluciones se puede representar como un vector:
    \[ (x_1, \cdots , x_n) \, : \qquad x_i \in \{1,2,3,4\} \quad \forall i \in \{1,\cdots,n\} \]
    donde $x_i$ representa la asignación del fragmento de caña $l_i$ a uno de los cuatro pilares.
    En forma de arbol se representaría de la siguiente manera, donde cada arista de la altura $i$ a un nodo de valor $k$ significa asignar $x_i=k$.
\end{frame}

\begin{frame}{Árbol}
    \begin{center}
        \begin{tikzpicture}[
            every node/.style={draw, circle, inner sep=3pt, font=\footnotesize},
            level 1/.style={sibling distance=30em, level distance=2.5em},
            level 2/.style={sibling distance=15em, level distance=2.5em},
            level 3/.style={sibling distance=6.5em,  level distance=2.5em},
            level 4/.style={sibling distance=1.8em, level distance=2.5em},
            scale=1.3, transform shape
        ]
            \node {0}
                child { node {1}
                    child { node {1}
                        child { node {1}
                            child { node {1} }
                            child { node {2} }
                        }
                        child { node {2}
                            child { node {1} }
                            child { node {2} }
                            child { node {3} }
                        }
                    }
                    child { node {2}
                        child { node {1}
                            child { node {1} }
                            child { node {2} }
                        }
                        child { node {2}
                            child { node {1} }
                            child { node {2} }
                            child { node {3} }
                        }
                        child { node {3}
                            child { node {1} }
                            child { node {2} }
                            child { node {3} }
                            child { node {4} }
                        }
                    }
                };
        \end{tikzpicture}
    \end{center}
\end{frame}

% Sección 4
\section{Cota optimista}
\begin{frame}[fragile]{Cota optimista}
    Para calcular la cota optimista, la idea sera ir dividiendo cada framgento (no se puede en el ejercicio, pero lo haremos para la cota), repartiendolo entre los cuatro pilares, y en el momento que todos tengan la misma altura, dividir cada fragmento restante entre los cuatro pilares, lo que nos dará una cota superior para la altura del pilar más bajo.\\
    Este algoritmo tendrá un coste de $O(n)$, ya que recorremos los fragmentos restantes y en cada paso encontramos el pilar más bajo en tiempo constante.\\
    Esto lo podemos hacer sumando todas las longitudes, primero igualamos los 2 pilares más bajos, luego los 3 pilares más bajos (2 de ellos ya estarán igualados), luego los 4 pilares (3 de ellos ya estarán igualados), y finalmente dividimos el resto entre los 4 pilares.
\end{frame}

\begin{frame}[fragile]{Cota optimista - Código}
    El código para calcular la cota optimista podría ser el siguiente:
    \begin{lstlisting}[language=C++]
        int cota_optimista {
            int longitud_restante = sum(longitudes.begin() + k, longitudes.end());
            vector<int> alturas_copia = alturas.sort(); // Copia de las alturas actuales
            // Igualar los pilares más bajos
            for (int i = 0; i < 3; i++) {
                int anadido = min(longitud_restante, (alturas_copia[i + 1] - alturas_copia[0]) * (i + 1));
                for (int j = 0; j <= i; j++) {
                    alturas_copia[j] += anadido / (i + 1);
                }
            }
            return alturas_copia[0] + longitud_restante / 4;
        }
    \end{lstlisting}
\end{frame}

% Sección 5
\section{Cota pesimista}
\begin{frame}[fragile]{Cota pesimista}
    En este problema es claro ver que cualquier solucion es factible, por mala que sea, por lo que para calcular una cota pesimista útil (siempre se podria usar 0, pero no nos serviria para nada), podemos ir asignando los fragmentos de caña al pilar más bajo en cada paso, lo que nos dará una cota inferior para la altura del pilar más bajo.\\
    Este algoritmo también tendrá un coste de $O(n)$, ya que recorremos los fragmentos restantes y en cada paso encontramos el pilar más bajo en tiempo constante.
\end{frame}

\begin{frame}[fragile]{Cota pesimista - Código}
    El código para calcular la cota pesimista podría ser el siguiente:
    \begin{lstlisting}[language=C++]
        int cota_pesimista(vector<int>& longitudes, vector<int>& alturas, int k) {
            vector<int> alturas_copia = alturas; // Copia de las alturas actuales
            // Igualamos
            for (int i = k; i < longitudes.size(); i++) {
                // Encontrar el pilar más bajo
                int min_index = 0;
                for (int j = 1; j < 4; j++) {
                    if (alturas_copia[j] < alturas_copia[min_index]) {
                        min_index = j;
                    }
                }
                // Asignar el fragmento al pilar más bajo
                alturas_copia[min_index] += longitudes[i];
            }
            return min(alturas);
        }
    \end{lstlisting}
\end{frame}

% Sección 6
\section{Algoritmo del ejercicio}
\begin{frame}[fragile]{Explicación del algoritmo}
    Para hacer una correcta implementación del algoritmo de ramificación y poda, podemos definir el siguiente tipo "nodo" que guardara la información necesaria para cada nodo del árbol de búsqueda, a la vez que la prioridad (para tener acceso al nodo mas prometedor), que será la altura del pilar más bajo en la asignación actual:
    \begin{lstlisting}[language=C++]
        struct Nodo {
            vector<int> alturas; // Alturas actuales de los pilares
            vector<int> asignaciones; // Asignación actual de fragmentos a pilares
            int k; // Índice del fragmento a asignar
            int prioridad; // Altura del pilar más bajo en la asignación actual
            int cota_op; // Cota optimista para el nodo actual
        };
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \begin{lstlisting}[language=C++, basicstyle=\ttfamily\tiny]
int ramificacion_y_poda(vector<int>& l, int n, int& mejor, vector<int>& mejor_asignacion) {
    priority_queue<Nodo> pq; // Cola de prioridad para los nodos
    Nodo raiz; // Inicialización del nodo raíz inicial
    raiz.prioridad = 0;
    raiz.cota_op = cota_optimista(l, raiz.alturas, 0);
    mejor = cota_pesimista(l, raiz.alturas, 0);
    pq.push(raiz, raiz.prioridad);
    while (!pq.empty()) {
        Nodo nodo = pq.top(); pq.pop();
        if (nodo.cota_op <= mejor) continue; // poda
        if (nodo.k == n) { // hoja
            mejor = max(mejor, min(nodo.alturas)); mejor_asignacion = nodo.asignaciones; continue;
        }
        set<int> vistos; // evitar ramas simetricas
        for (int j = 0; j < 4; j++) {
            if (vistos.count(nodo.alturas[j])) continue;
            vistos.insert(nodo.alturas[j]);
            Nodo hijo; hijo.alturas = nodo.alturas;
            hijo.alturas[j] += l[nodo.k]; hijo.k = nodo.k + 1;
            hijo.prioridad = min(hijo.alturas[j], nodo.prioridad);
            hijo.cota_op = cota_optimista(l, hijo.alturas, hijo.k);
            if (hijo.cota_op > mejor) {
                mejor = max(mejor, cota_pesimista(l, hijo.alturas, hijo.k));
                pq.push(hijo, hijo.prioridad);
            }
        }
    }
    return mejor;
}
    \end{lstlisting}
\end{frame}

% Sección 7
\section{Complejidad del algoritmo}
\begin{frame}{Complejidad del algoritmo}
    La complejidad del algoritmo de ramificación y poda en el peor caso es $O(n 4^n)$, ya que en el peor caso se exploran todas las combinaciones posibles de asignación de los fragmentos a los pilares, lo que da lugar a $4^n$ combinaciones, y para cada combinación se calcula la cota optimista y pesimista en $O(n)$, auqnue en la práctica, la poda puede reducir significativamente el número de combinaciones exploradas gracias a las podas que se realizan al comparar la cota optimista con la mejor solución encontrada hasta el momento.\\
    El coste en espacio es $O(n)$, ya que en cada momento se almacenan las alturas de los pilares y las asignaciones de los fragmentos, lo que requiere espacio lineal en el número de fragmentos. \\
    Notese que si la mejor solucion coincide con la cota pesimista inicial, se tendria que calcular la asignacion exacta volviendo a realizar el proceso de asignacion de los fragmentos al pilar más bajo, lo que se podria hacer en $O(n)$, por lo que el coste total del algoritmo en dicho caso no cambia.
\end{frame}

\end{document}