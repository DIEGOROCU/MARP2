\documentclass[aspectratio=169]{beamer}

% Tema y configuración
\usetheme{Madrid}
\usecolortheme{default}

% Paquetes necesarios
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
% Habilitar UTF-8 dentro de lstlisting (acentos, ñ, etc.)
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{verbatim}
% Para dibujos con TikZ
\usepackage{tikz}
\usetikzlibrary{positioning,trees}

% Configuración de listings para código
\lstset{
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    inputencoding=utf8,
    % Mapeo de caracteres españoles para que no falle la compilación
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'\i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
             {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
             {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {ü}{{\"u}}1 {Ü}{{\"U}}1
}

% Información del documento
\title{Hoja 1: Ejercicio 2}
\subtitle{TEMA}
\author{Diego Rodríguez Cubero}
\institute{UCM}

% Logo (opcional)
% \logo{\includegraphics[height=1cm]{images/logo.png}}

\begin{document}

% Diapositiva de título
\begin{frame}
    \titlepage
\end{frame}

% Tabla de contenidos
\begin{frame}{Contenidos}
    \tableofcontents
\end{frame}

% Sección 1
\section{Enunciado del problema}
\begin{frame}{Enunciado del problema}
    \begin{block}{El rapero con sueltecillo}
        Un rapero lleva excesivo dinero suelto en el bolsillo de su pantalón, lo que contribuye a que lleve los pantalones demasiado caídos. Como consecuencia, cada vez que paga una cantidad C, su deseo es emplear el mayor número posible de monedas. Suponiendo que para todo $i, 1 \leq i \leq n$, tiene $n_i$ monedas del tipo $m_i$, diseñar un algoritmo que le diga cuáles monedas debe emplear
    \end{block}
\end{frame}

% Sección 2
\section{Idea Principal}
\begin{frame}{Idea Principal}
    La idea principal del algoritmo es similar a la del problema de las monedas, pero en este caso, en lugar de minimizar el número de monedas, se busca maximizarlo.   
\end{frame}

% Sección 3
\section{Algoritmo propuesto}
\begin{frame}{Algoritmo propuesto}
    Llamemos $\text{monedas}(i,j)=$ número máximo de monedas que se pueden usar para pagar j euros usando los primeros i tipos de monedas. Entonces, la recurrencia es:
    \[
        \text{monedas}(i,j) = \max_{0 \leq k \leq n_i, k \cdot m_i \leq j} \{ k + \text{monedas}(i-1, j - k \cdot m_i) \}
    \]
    Y los casos base son:
    \[
        \text{monedas}(0,j) = -\infty \quad \text{para todo } j \geq 0
    \]
    y
    \[        
        \text{monedas}(i,0) = 0 \quad \text{para todo } i \geq 0
    \]
\end{frame}

\begin{frame}[fragile]{Pseudocódigo del algoritmo}
    \begin{lstlisting}[language=C++, caption=Pseudocódigo del algoritmo propuesto]
        function max_monedas(n, m, N, C):
        // n (tipos de monedas), m (valores de las monedas), N (número de monedas de cada tipo), C (cantidad a pagar)
        crear matriz monedas[n+1][C+1]
        para j desde 0 hasta C:
            monedas[0][j] = -infinity
        para i desde 0 hasta n:
            monedas[i][0] = 0
        para i desde 1 hasta n:
            para j desde 1 hasta C:
                max_monedas = -infinity
                para k desde 0 hasta N[i-1]:
                    si k * m[i-1] <= j:
                        max_monedas = max(max_monedas, k + monedas[i-1][j - k * m[i-1]])
                monedas[i][j] = max_monedas
        return monedas[n][C]
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Reconstruccion de la solución}
    \begin{lstlisting}[language=C++, caption=Reconstrucción de la solución]
        function reconstruir_solucion(monedas, n, m, N, C):
        i = n
        j = C
        resultado = []
        mientras i > 0 y j > 0:
            para k desde 0 hasta N[i-1] {
                si k * m[i-1] <= j // No nos pasamos de j
                // Lo optimo es usar k monedas del tipo i-1
                && monedas[i][j] == k + monedas[i-1][j - k * m[i-1]]:
                        resultado.agregar((m[i-1], k))
                        j = j - k * m[i-1]
                        romper
            }
            i = i - 1
            si k == N[i-1] + 1: // No se usó ninguna moneda de este tipo
                resultado.agregar((m[i-1], 0))
        return resultado
    \end{lstlisting}
    
\end{frame}

% Sección 4
\section{Complejidad del algoritmo}
\begin{frame}{Complejidad del algoritmo}
    La complejidad temporal del algoritmo es $O(n \cdot C \cdot \max(N_i))$. Esto se debe a que para crear la solucion recorremos una matriz de tamaño $n \cdot C$ y para cada celda, en el peor caso, tendremos que iterar hasta $N_i$ veces para encontrar el máximo número de monedas que se pueden usar. La reconstruccion de la solución tiene una complejidad de $O(n \cdot \max(N_i))$ en el peor caso, ya que en el peor caso, podríamos tener que revisar todas las posibles cantidades de monedas para cada tipo.
    La complejidad en espacio es $O(n \cdot C)$ debido a la matriz utilizada para almacenar los resultados intermedios.
\end{frame}

% Sección 5
\section{Otra forma de resolver el problema}
\begin{frame}{Otra forma de resolver el problema}
    Podemos ahorrarnos el tiempo de la reconstruccion de la solución si, en lugar de almacenar solo el número máximo de monedas, almacenamos también la cantidad de monedas de cada tipo que se usó para alcanzar ese máximo. De esta manera, al finalizar el algoritmo, tendremos directamente la solución sin necesidad de recorrer la matriz nuevamente. Esto se puede hacer manteniendo una matriz adicional que almacene la cantidad de monedas de cada tipo que se usó para alcanzar el máximo número de monedas en cada celda. La complejidad temporal seguiría siendo $O(n \cdot C \cdot \max(N_i))$, pero la reconstrucción de la solución se reduciría a $O(n)$, ya que simplemente tendríamos que leer la matriz adicional para obtener la cantidad de monedas de cada tipo que se usó.
    Los costes en espacio se incrementarían a $O(n \cdot C + n \cdot \max(N_i))$ debido a la matriz adicional para almacenar la cantidad de monedas de cada tipo, aunque asintoticamente no cambiarian ninguno de los dos costes.
\end{frame}

\begin{frame}[fragile]
    \begin{lstlisting}[language=C++, caption=Pseudocódigo del algoritmo alternativo]
        function max_monedas_alternativo(n, m, N, C):
        crear matriz monedas[n+1][C+1]
        crear matriz cantidad_monedas[n+1][C+1] // Monedas usadas
        para j desde 0 hasta C:
            monedas[0][j] = -infinity
        para i desde 0 hasta n:
            monedas[i][0] = 0
        para i desde 1 hasta n:
            para j desde 1 hasta C:
                max_monedas = -infinity
                cantidad_usada = 0
                para k desde 0 hasta N[i-1]:
                    si k * m[i-1] <= j:
                        if k + monedas[i-1][j - k * m[i-1]] > max_monedas:
                            max_monedas = k + monedas[i-1][j - k * m[i-1]]
                            cantidad_usada = k
                monedas[i][j] = max_monedas
                cantidad_monedas[i][j] = cantidad_usada // Almacenar la cantidad de monedas usada
        return monedas[n][C], cantidad_monedas
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Solucion}
    Ahora para conocer cuantas monedas de cada tipo se han usado, simplemente tenemos que leer la matriz cantidad\_monedas. Por ejemplo, para el tipo de moneda i, la cantidad de monedas usadas para pagar C euros sería cantidad\_monedas[i][C].
    \begin{lstlisting}{language=C++, caption=Obtener la solución directamente}
        function obtener_solucion(cantidad_monedas, n, C):
        resultado = []
        for i from 1 to n:
            resultado.agregar((m[i-1], cantidad_monedas[i][C]))
            C = C - cantidad_monedas[i][C] * m[i-1] // Actualizar la cantidad restante a pagar
        return resultado
    \end{lstlisting}
    Esta funcion tiene de coste en tiempo $O(n)$, ya que simplemente recorremos la matriz cantidad\_monedas una vez para obtener la cantidad de monedas de cada tipo que se usó para pagar la cantidad C, y en espacio $O(n)$ para almacenar el resultado.
\end{frame}

% Sección 6
\section{Conclusión}
\begin{frame}{Conclusión}
    Hemos diseñado un algoritmo para resolver el problema, basandonos al inicio en la idea del problema de las monedas, pero adaptándolo para maximizar el número de monedas utilizadas. La solución se basa en una programación dinámica que nos permite calcular el número máximo de monedas que se pueden usar para pagar una cantidad dada, teniendo en cuenta las restricciones de cantidad y tipos de monedas disponibles.
\end{frame}

\end{document}